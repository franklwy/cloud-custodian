#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
华为云CCI Namespace API调用示例
演示如何使用AK/SK访问华为云CCI服务获取所有namespace
"""

import copy
import sys
import hashlib
import hmac
import binascii
import requests
import json
from datetime import datetime
from urllib.parse import quote, unquote


def hmacsha256(byte, msg):
    return hmac.new(byte.encode('utf-8'),
                    msg.encode('utf-8'),
                    digestmod=hashlib.sha256).digest()


def urlencode(str):
    return quote(str, safe='~')


def findHeader(req, h):
    for header in req.headers:
        if header.lower() == h.lower():
            return req.headers[header]
    return None


def HexEncodeSHA256Hash(d):
    sha = hashlib.sha256()
    sha.update(d)
    return sha.hexdigest()


class HttpRequest:
    def __init__(self, m="", u="", h=None, b=""):
        self.method = m
        sp = u.split("://", 1)
        s = 'http'
        if len(sp) > 1:
            s = sp[0]
            u = sp[1]
        q = {}
        sp = u.split('?', 1)
        u = sp[0]
        if len(sp) > 1:
            for kv in sp[1].split("&"):
                sp = kv.split("=", 1)
                k = sp[0]
                v = ""
                if len(sp) > 1:
                    v = sp[1]
                if k != '':
                    k = unquote(k)
                    v = unquote(v)
                    if k in q:
                        q[k].append(v)
                    else:
                        q[k] = [v]
        sp = u.split('/', 1)
        host = sp[0]
        if len(sp) > 1:
            u = '/' + sp[1]
        else:
            u = '/'

        self.scheme = s
        self.host = host
        self.uri = u
        self.query = q
        if h is None:
            self.headers = {}
        else:
            self.headers = copy.deepcopy(h)
        self.body = b.encode("utf-8") if isinstance(b, str) else b


DateFormat = "%Y%m%dT%H%M%SZ"
Alg = "SDK-HMAC-SHA256"
HXDate = "X-Sdk-Date"
HHost = "host"
HAuthorization = "Authorization"
HContentSha256 = "x-sdk-content-sha256"


def StringToSign(request, time):
    b = HexEncodeSHA256Hash(request.encode('utf-8'))
    return "%s\n%s\n%s" % (Alg, datetime.strftime(time, DateFormat), b)


def CanonicalRequest(req, sHeaders):
    canonicalHeaders = CanonicalHeaders(req, sHeaders)
    hencode = findHeader(req, HContentSha256)
    if hencode is None:
        hencode = HexEncodeSHA256Hash(req.body)
    return "%s\n%s\n%s\n%s\n%s\n%s" % (req.method.upper(), CanonicalURI(req),
                                       CanonicalQueryString(req),
                                       canonicalHeaders,
                                       ";".join(sHeaders), hencode)


def CanonicalURI(req):
    patterns = unquote(req.uri).split('/')
    uri = []
    for value in patterns:
        uri.append(urlencode(value))
    url_path = "/".join(uri)
    if url_path[-1] != '/':
        url_path = url_path + "/"
    return url_path


def CanonicalQueryString(req):
    keys = []
    for key in req.query:
        keys.append(key)
    keys.sort()
    arr = []
    for key in keys:
        ke = urlencode(key)
        value = req.query[key]
        if type(value) is list:
            value.sort()
            for v in value:
                kv = ke + "=" + urlencode(str(v))
                arr.append(kv)
        else:
            kv = ke + "=" + urlencode(str(value))
            arr.append(kv)
    return '&'.join(arr)


def CanonicalHeaders(req, sHeaders):
    arr = []
    _headers = {}
    for k in req.headers:
        keyEncoded = k.lower()
        value = req.headers[k]
        valueEncoded = value.strip()
        _headers[keyEncoded] = valueEncoded
        req.headers[k] = valueEncoded.encode("utf-8").decode('iso-8859-1')
    for k in sHeaders:
        arr.append(k + ":" + _headers[k])
    return '\n'.join(arr) + "\n"


def SignedHeaders(req):
    arr = []
    for k in req.headers:
        arr.append(k.lower())
    arr.sort()
    return arr


def SignStringToSign(strToSign, sigKey):
    hmac_digest = hmacsha256(sigKey, strToSign)
    return binascii.hexlify(hmac_digest).decode()


def AuthHeaderValue(sig, AppKey, sHeaders):
    return "%s Access=%s, SignedHeaders=%s, Signature=%s" % (
        Alg, AppKey, ";".join(sHeaders), sig)


class Signer:
    def __init__(self):
        self.Key = ""
        self.Secret = ""

    def Sign(self, req):
        if isinstance(req.body, str):
            req.body = req.body.encode('utf-8')
        
        headerTime = findHeader(req, HXDate)
        if headerTime is None:
            time = datetime.utcnow()
            req.headers[HXDate] = datetime.strftime(time, DateFormat)
        else:
            time = datetime.strptime(headerTime, DateFormat)

        haveHost = False
        for key in req.headers:
            if key.lower() == 'host':
                haveHost = True
                break
        if not haveHost:
            req.headers["host"] = req.host
        req.headers["content-length"] = str(len(req.body))
        
        queryString = CanonicalQueryString(req)
        if queryString != "":
            req.uri = req.uri + "?" + queryString
            
        signedHeaders = SignedHeaders(req)
        canonicalRequest = CanonicalRequest(req, signedHeaders)
        stringToSign = StringToSign(canonicalRequest, time)
        signature = SignStringToSign(stringToSign, self.Secret)
        authValue = AuthHeaderValue(signature, self.Key, signedHeaders)
        req.headers[HAuthorization] = authValue


def get_cci_namespaces(access_key, secret_key, region):
    """
    获取华为云CCI所有namespace
    """
    # 根据华为云官方文档，CCI API端点格式为：cci.{region}.myhuaweicloud.com
    # 同时添加一些调试信息
    print(f"🔍 正在使用区域: {region}")
    print(f"🔑 访问密钥ID: {access_key[:8]}...")
    
    possible_urls = [
        f"https://cci.{region}.myhuaweicloud.com/api/v1/namespaces",  # 华为云标准格式
    ]
    
    for i, url in enumerate(possible_urls, 1):
        print(f"\n尝试第{i}个端点: {url}")
        if try_single_endpoint(url, access_key, secret_key):
            return True
    
    return False


def try_single_endpoint(url, access_key, secret_key):
    """
    尝试单个端点
    """
    # 创建HTTP请求对象
    request = HttpRequest("GET", url, {}, "")
    
    # 创建签名器
    signer = Signer()
    signer.Key = access_key
    signer.Secret = secret_key
    
    # 对请求进行签名
    print(f"准备签名请求...")
    print(f"签名前的headers: {request.headers}")
    signer.Sign(request)
    print(f"签名后的headers: {request.headers}")
    
    # 发送请求
    try:
        print(f"发送GET请求到: {url}")
        response = requests.get(url, headers=request.headers, timeout=30)
        print(f"响应状态码: {response.status_code}")
        
        if response.status_code == 200:
            print(f"✅ 请求成功！")
            print(f"响应头: {dict(response.headers)}")
            
            # 格式化输出JSON响应
            response_data = response.json()
            print(f"响应内容:")
            print(json.dumps(response_data, indent=2, ensure_ascii=False))
            
            # 解析namespace信息
            if "items" in response_data:
                namespaces = response_data["items"]
                print(f"\n找到 {len(namespaces)} 个namespace:")
                for i, ns in enumerate(namespaces, 1):
                    name = ns.get("metadata", {}).get("name", "Unknown")
                    creation_time = ns.get("metadata", {}).get("creationTimestamp", "Unknown")
                    status = ns.get("status", {}).get("phase", "Unknown")
                    print(f"{i}. 名称: {name}, 状态: {status}, 创建时间: {creation_time}")
            return True
        else:
            print(f"❌ 请求失败，状态码: {response.status_code}")
            print(f"响应内容: {response.text}")
            return False
        
    except requests.exceptions.RequestException as e:
        print(f"❌ 网络请求异常: {e}")
        return False
    except json.JSONDecodeError as e:
        print(f"❌ JSON解析失败: {e}")
        print(f"原始响应: {response.text}")
        return False
    except Exception as e:
        print(f"❌ 未知错误: {e}")
        return False


def main():
    """
    主函数
    """
    # 华为云认证信息（从环境变量或直接设置）
    access_key = ""
    secret_key = ""
    # 注意：cn-east-4 不支持CCI服务，改用 cn-north-4
    region = "cn-north-4"  # 华北-北京四，支持CCI服务
    
    print("华为云CCI Namespace API调用示例")
    print("=" * 50)
    print(f"Region: {region}")
    print(f"Access Key: {access_key[:8]}***")
    print("=" * 50)
    
    # 调用API获取namespace列表
    result = get_cci_namespaces(access_key, secret_key, region)
    
    if result:
        print("\n🎉 成功找到可用的CCI API端点并获取到namespace信息！")
    else:
        print("\n❌ 所有端点都无法访问，可能的原因:")
        print("   1. 网络连接问题")
        print("   2. 认证信息有误")
        print("   3. 区域不支持CCI服务")
        print("   4. API端点格式发生了变化")


if __name__ == "__main__":
    main() 
